<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Universal Solana Wallet DApp (Helius)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
body{font-family:Arial,Helvetica,sans-serif;display:flex;justify-content:center;padding:40px;background:#f0f2f5}
#walletApp{max-width:700px;width:100%;padding:20px;background:#fff;border-radius:10px;box-shadow:0 6px 24px rgba(0,0,0,0.08)}
select,button{width:48%;padding:12px;border-radius:8px;border:0;font-size:15px;cursor:pointer;margin:5px}
button{background:#4caf50;color:#fff}
button:hover{background:#45a049}
#logs{margin-top:12px;padding:12px;border-radius:8px;background:#e8f4fd;white-space:pre-wrap;max-height:420px;overflow:auto;text-align:left}
h2{margin:0 0 12px 0}
.note{font-size:13px;color:#666;margin-top:8px}
</style>
</head>
<body>
<div id="walletApp">
  <h2>Universal Solana Wallet DApp (Helius)</h2>

  <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:8px">
    <select id="walletSelect"><option value="">Select Wallet</option></select>
  </div>

  <div style="text-align:center">
    <button id="connectWallet">Connect Wallet</button>
    <button id="disconnectWallet">Disconnect Wallet</button>
    <button id="reclaimRentBtn">üßπ Reclaim Rent</button>
  </div>

  <div class="note">Using Helius RPC (demo key) ‚Äî do not commit private keys to public repos.</div>
  <div id="logs">Logs will appear here...</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.91.0/lib/index.iife.min.js"></script>

<script>
(function () {
  const HELIUS_RPC = 'https://mainnet.helius-rpc.com/?api-key=b933e448-6fee-4016-b4ec-3c6c19a46775';
  const FALLBACK_RPC = 'https://solana-api.projectserum.com';
  const TOKEN_PROGRAM = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';

  const logsEl = document.getElementById('logs');
  const walletSelect = document.getElementById('walletSelect');
  const connectBtn = document.getElementById('connectWallet');
  const disconnectBtn = document.getElementById('disconnectWallet');
  const reclaimBtn = document.getElementById('reclaimRentBtn');

  let wallet = null;
  let publicKey = null;
  let connection = null;

  function logStep(msg) {
    console.log(msg);
    logsEl.innerText += msg + '\n';
    logsEl.scrollTop = logsEl.scrollHeight;
  }

  function waitForWeb3(timeoutMs = 5000) {
    return new Promise((resolve, reject) => {
      const start = Date.now();
      (function poll() {
        const g = window.solanaWeb3 || window.web3 || window.web3js || window.solanaWeb3js;
        if (g) return resolve(g);
        if (Date.now() - start > timeoutMs) return reject(new Error('web3 global not found'));
        setTimeout(poll, 150);
      })();
    });
  }

  function detectWallets() {
    const out = [];
    if (window.phantom?.solana?.isPhantom) out.push({ wallet: window.phantom.solana, name: 'Phantom' });
    if (window.solana && window.solana.isPhantom && !out.find(x=>x.name==='Phantom')) out.push({ wallet: window.solana, name: 'Phantom' });
    if (window.solflare && window.solflare.isSolflare) out.push({ wallet: window.solflare, name: 'Solflare' });
    if (window.Slope) { try { out.push({ wallet: new window.Slope(), name: 'Slope' }); } catch(e) {} }
    return out;
  }

  function populateWalletDropdown() {
    walletSelect.innerHTML = '<option value="">Select Wallet</option>';
    const detected = detectWallets();
    detected.forEach(w => {
      const opt = document.createElement('option');
      opt.value = w.name;
      opt.textContent = w.name;
      walletSelect.appendChild(opt);
    });
    logStep('Detected wallets: ' + detected.map(d => d.name).join(', '));
  }

  function getSelectedWallet() {
    const name = walletSelect.value;
    return detectWallets().find(w => w.name === name);
  }

  function buildConnection(web3Global) {
    try { return new web3Global.Connection(HELIUS_RPC, 'confirmed'); }
    catch(e) { logStep('‚ö†Ô∏è Helius RPC failed, falling back: ' + e.message); }
    try { const g = window.solanaWeb3 || window.web3 || window.web3js || window.solanaWeb3js; return new g.Connection(FALLBACK_RPC, 'confirmed'); }
    catch(e) { logStep('‚ùå Cannot create RPC: '+e.message); throw e; }
  }

  async function init() {
    try {
      const web3Global = await waitForWeb3(7000).catch(() => window.solanaWeb3 || window.web3 || window.web3js || window.solanaWeb3js);
      if (!web3Global) { logStep('‚ùå web3 not found'); return; }
      logStep('‚úÖ web3 loaded');
      connection = buildConnection(web3Global);
      logStep('‚úÖ RPC ready');
      populateWalletDropdown();
    } catch(e){ logStep('‚ùå Init error: '+e.message); console.error(e); }
  }

  async function connectWalletFunc() {
    logsEl.innerText = '';
    const wObj = getSelectedWallet();
    if (!wObj) { logStep('‚ùå Select a wallet first'); return; }
    try {
      logStep('Connecting ' + wObj.name + '...');
      const resp = await wObj.wallet.connect();
      publicKey = resp?.publicKey || wObj.wallet?.publicKey;
      if (publicKey && publicKey.toString) publicKey = publicKey.toString();
      logStep('Connected: ' + publicKey);

      // SOL Balance
      const lamports = await connection.getBalance(new (window.solanaWeb3 || window.web3 || window.web3js).PublicKey(publicKey));
      logStep('üí∞ SOL Balance: ' + (lamports / 1e9).toFixed(6) + ' SOL');

      // SPL Tokens
      const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
        new (window.solanaWeb3 || window.web3 || window.web3js).PublicKey(publicKey),
        { programId: new (window.solanaWeb3 || window.web3 || window.web3js).PublicKey(TOKEN_PROGRAM) }
      );
      if (!tokenAccounts?.value?.length) logStep('No SPL tokens found.');
      else tokenAccounts.value.forEach((t,i)=>{
        try {
          const info = t.account.data.parsed.info;
          logStep(`${i+1}. Mint: ${info.mint}, Amount: ${info.tokenAmount.uiAmountString}`);
        } catch(e){ logStep(`${i+1}. Token account (raw): ${JSON.stringify(t)}`); }
      });

      wallet = wObj.wallet;
    } catch(err){ logStep('‚ùå Connect error: '+err.message); console.error(err); }
  }

  async function disconnectWalletFunc() {
    if (!wallet) { logStep('‚ùå No wallet connected'); return; }
    try { await wallet.disconnect(); logStep('Wallet disconnected'); wallet=null; publicKey=null; }
    catch(err){ logStep('‚ùå Disconnect error: '+err.message); console.error(err); }
  }

    // ---------- Reclaim Rent ----------
    const DUST_THRESHOLD_USD = 0.01; // treat accounts < 1 cent as empty
  
  async function getTokenPrices(mints) {
    // Helius API: fetch multiple token prices at once
    const res = await fetch('https://api.helius.xyz/v0/token-prices?api-key=b933e448-6fee-4016-b4ec-3c6c19a46775', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ mints })
    });
    const data = await res.json();
    const priceMap = {};
    data.forEach(p => {
      priceMap[p.mint] = p.price || 0;
    });
    return priceMap;
  }
  
  async function reclaimRent() {
    clearLogs();
    log('üßπ Reclaim Rent started...');
    await session.disconnectAll();
  
    const walletObj = getSelectedWallet();
    if(!walletObj){ log('‚ùå No wallet selected.'); return; }
  
    let wallet, pubkey;
    try {
      const result = await session.connect(walletObj);
      wallet = result.wallet;
      pubkey = result.publicKey;
      log('Connected wallet: ' + pubkey);
    } catch(err) {
      log('‚ùå Wallet connect failed: ' + err.message);
      return;
    }
  
    // Fetch token accounts
    let tokenAccounts;
    try {
      tokenAccounts = await connection.getParsedTokenAccountsByOwner(
        new solanaWeb3.PublicKey(pubkey),
        { programId: new solanaWeb3.PublicKey(TOKEN_PROGRAM) }
      );
    } catch(e) {
      log('‚ùå Failed to fetch token accounts: ' + e.message);
      return;
    }
  
    if(!tokenAccounts || tokenAccounts.value.length === 0) {
      log('‚úÖ No token accounts found.');
      return;
    }
  
    // Gather mints to query prices
    const mints = tokenAccounts.value.map(t => t.account.data.parsed.info.mint);
    const priceMap = await getTokenPrices(mints);
  
    // Filter "empty" accounts by USD value
    const empty = tokenAccounts.value.filter(t => {
      const amount = Number(t.account.data.parsed.info.tokenAmount.uiAmount);
      const mint = t.account.data.parsed.info.mint;
      const price = priceMap[mint] || 0;
      const valueUSD = amount * price;
      return valueUSD < DUST_THRESHOLD_USD;
    });
  
    if(empty.length === 0){
      log('‚úÖ No empty (dust) token accounts found ‚Äî nothing to reclaim.');
      return;
    }
  
    log(`ü™£ Found ${empty.length} empty/dust token account(s). Closing...`);
  
    for(const entry of empty){
      const tokenAcctPubkey = entry.pubkey;
      try{
        const keys=[
          {pubkey: tokenAcctPubkey,isSigner:false,isWritable:true},
          {pubkey:new solanaWeb3.PublicKey(pubkey),isSigner:false,isWritable:true},
          {pubkey:new solanaWeb3.PublicKey(pubkey),isSigner:true,isWritable:false}
        ];
        const ix = new solanaWeb3.TransactionInstruction({
          keys,
          programId: new solanaWeb3.PublicKey(TOKEN_PROGRAM),
          data: Buffer.from([9])
        });
        const tx = new solanaWeb3.Transaction().add(ix);
        tx.feePayer = new solanaWeb3.PublicKey(pubkey);
        const { blockhash } = await connection.getLatestBlockhash();
        tx.recentBlockhash = blockhash;
  
        let sig;
        if(wallet.signTransaction){
          const signedTx = await wallet.signTransaction(tx);
          sig = await connection.sendRawTransaction(signedTx.serialize());
        } else if(wallet.signAndSendTransaction){
          const res = await wallet.signAndSendTransaction(tx);
          sig = res?.signature || res;
        } else{
          throw new Error('Wallet cannot sign transaction');
        }
        await connection.confirmTransaction(sig,'confirmed');
        log(`‚úÖ Closed ${tokenAcctPubkey.toString()} ‚Äî tx ${sig}`);
      } catch(err){
        log(`‚ùå Failed to close ${tokenAcctPubkey.toString()}: ${err?.message||String(err)}`);
      }
    }
  
    log('üéâ Reclaim run complete.');
  }
  }

  // Wire buttons
  connectBtn.addEventListener('click', connectWalletFunc);
  disconnectBtn.addEventListener('click', disconnectWalletFunc);
  reclaimBtn.addEventListener('click', reclaimRentFunc);

  // Init
  init();

  // Refresh wallet dropdown periodically (detect new wallets)
  setInterval(()=>{
    const had = walletSelect.options.length;
    const detected = detectWallets();
    if(detected.length + 1 !== had){ populateWalletDropdown(); }
  }, 3000);

})();
</script>
</body>
</html>

