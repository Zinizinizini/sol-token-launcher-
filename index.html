<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Universal Solana Wallet DApp (Helius)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
body{font-family:Arial,Helvetica,sans-serif;display:flex;justify-content:center;padding:40px;background:#f0f2f5}
#walletApp{max-width:700px;width:100%;padding:20px;background:#fff;border-radius:10px;box-shadow:0 6px 24px rgba(0,0,0,0.08)}
select,button{width:48%;padding:12px;border-radius:8px;border:0;font-size:15px;cursor:pointer;margin:5px}
button{background:#4caf50;color:#fff}
button:hover{background:#45a049}
#logs{margin-top:12px;padding:12px;border-radius:8px;background:#e8f4fd;white-space:pre-wrap;max-height:420px;overflow:auto;text-align:left}
h2{margin:0 0 12px 0}
.note{font-size:13px;color:#666;margin-top:8px}
</style>
</head>
<body>
<div id="walletApp">
  <h2>Universal Solana Wallet DApp (Helius)</h2>

  <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:8px">
    <select id="walletSelect"><option value="">Select Wallet</option></select>
  </div>

  <div style="text-align:center">
    <button id="connectWallet">Connect Wallet</button>
    <button id="disconnectWallet">Disconnect Wallet</button>
    <button id="reclaimRentBtn">ðŸ§¹ Reclaim Rent</button>
  </div>

  <div class="note">Using Helius RPC (demo key) â€” do not commit private keys to public repos.</div>
  <div id="logs">Logs will appear here...</div>
</div>

<!-- Solana Web3 -->
<script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.91.0/lib/index.iife.min.js"></script>

<script>
// ---------- WALLET SESSION MANAGER ----------
class WalletSessionManager {
  constructor() {
    this.activeWallet = null;
    this.publicKey = null;
  }

  async connect(walletObj) {
    if (!walletObj) throw new Error('No wallet object provided');
    if (this.activeWallet && this.activeWallet !== walletObj) await this.disconnect();

    let pubkey;
    if (walletObj.isConnected && walletObj.publicKey) {
      pubkey = walletObj.publicKey.toString();
    } else if (walletObj.publicKey && walletObj.publicKey.toBase58) {
      pubkey = walletObj.publicKey.toBase58();
    } else {
      const resp = await walletObj.connect();
      pubkey = resp?.publicKey?.toString() || walletObj.publicKey?.toString();
    }

    if (!pubkey) throw new Error('Unable to get public key from wallet');
    this.activeWallet = walletObj;
    this.publicKey = pubkey;
    log('ðŸŸ¢ Connected wallet: ' + pubkey);
    return { wallet: walletObj, publicKey: pubkey };
  }

  async disconnect() {
    if (!this.activeWallet) return;
    try {
      if (this.activeWallet.disconnect) await this.activeWallet.disconnect();
      else if (this.activeWallet.signOut) await this.activeWallet.signOut();
      log('âšª Wallet disconnected: ' + this.publicKey);
    } catch (err) {
      log('âš ï¸ Disconnect error: ' + err.message);
    } finally {
      this.activeWallet = null;
      this.publicKey = null;
    }
  }

  async disconnectAll() {
    const wallets = [window.solana, window.phantom?.solana, window.solflare, window.Slope];
    for (const w of wallets) {
      if (!w) continue;
      try { if (w.disconnect) await w.disconnect(); else if (w.signOut) await w.signOut(); } catch {}
    }
    this.activeWallet = null;
    this.publicKey = null;
  }
}

window.walletSessionManager = new WalletSessionManager();

// ---------- UTILS ----------
const HELIUS_RPC = 'https://mainnet.helius-rpc.com/?api-key=b933e448-6fee-4016-b4ec-3c6c19a46775';
const TOKEN_PROGRAM = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
const logsEl = document.getElementById('logs');
const session = window.walletSessionManager;

function log(msg){ console.log(msg); logsEl.innerText += msg + '\n'; logsEl.scrollTop = logsEl.scrollHeight; }
function clearLogs(){ logsEl.innerText = ''; }

function detectWallets() {
  const providers = [];
  if(window.solana?.isPhantom) providers.push({wallet: window.solana, name:'Phantom'});
  if(window.phantom?.solana?.isPhantom) providers.push({wallet: window.phantom.solana, name:'Phantom'});
  if(window.solflare?.isSolflare) providers.push({wallet: window.solflare, name:'Solflare'});
  if(window.Slope) try{ providers.push({wallet: new window.Slope(), name:'Slope'}); } catch{}
  log('Detected wallets: ' + providers.map(p=>p.name).join(', '));
  return providers;
}

function populateDropdown() {
  const sel = document.getElementById('walletSelect');
  sel.innerHTML = '<option value="">Select Wallet</option>';
  detectWallets().forEach(w=> {
    const opt = document.createElement('option');
    opt.value = w.name;
    opt.textContent = w.name;
    sel.appendChild(opt);
  });
}

function getSelectedWallet() {
  const sel = document.getElementById('walletSelect');
  const name = sel.value;
  return detectWallets().find(p=>p.name===name)?.wallet || detectWallets()[0]?.wallet || null;
}

// ---------- RPC CONNECTION ----------
let connection;
try { connection = new solanaWeb3.Connection(HELIUS_RPC, 'confirmed'); log('âœ… Connected to Helius RPC'); } 
catch(e){ log('âš ï¸ Helius RPC connection failed: ' + e.message); }

// ---------- RECLAIM FUNCTION ----------
async function reclaimRent() {
  clearLogs();
  log('ðŸ§¹ Reclaim Rent started...');
  await session.disconnectAll();

  const walletObj = getSelectedWallet();
  if(!walletObj){ log('âŒ No wallet selected.'); return; }

  let wallet, pubkey;
  try{
    const result = await session.connect(walletObj);
    wallet = result.wallet;
    pubkey = result.publicKey;
  } catch(err){ log('âŒ Wallet connect failed: '+err.message); return; }

  let tokenAccounts;
  try {
    tokenAccounts = await connection.getParsedTokenAccountsByOwner(
      new solanaWeb3.PublicKey(pubkey),
      { programId: new solanaWeb3.PublicKey(TOKEN_PROGRAM) }
    );
  } catch(e){ log('âŒ Fetch token accounts failed: '+e.message); return; }

  const empty = tokenAccounts.value.filter(t=>Number(t.account.data.parsed.info.tokenAmount.uiAmount)===0);
  if(empty.length===0){ log('âœ… No empty token accounts found.'); return; }

  log(`ðŸª£ Found ${empty.length} empty token account(s). Closing...`);

  for(const entry of empty){
    const tokenAcctPubkey = entry.pubkey;
    try{
      const keys=[
        {pubkey: tokenAcctPubkey,isSigner:false,isWritable:true},
        {pubkey:new solanaWeb3.PublicKey(pubkey),isSigner:false,isWritable:true},
        {pubkey:new solanaWeb3.PublicKey(pubkey),isSigner:true,isWritable:false}
      ];
      const ix = new solanaWeb3.TransactionInstruction({keys,programId:new solanaWeb3.PublicKey(TOKEN_PROGRAM),data:Buffer.from([9])});
      const tx = new solanaWeb3.Transaction().add(ix);
      tx.feePayer = new solanaWeb3.PublicKey(pubkey);
      const { blockhash } = await connection.getLatestBlockhash();
      tx.recentBlockhash = blockhash;

      if(wallet.signTransaction){
        const signedTx = await wallet.signTransaction(tx);
        const raw = signedTx.serialize();
        const sig = await connection.sendRawTransaction(raw);
        await connection.confirmTransaction(sig,'confirmed');
        log(`âœ… Closed ${tokenAcctPubkey.toString()} â€” tx ${sig}`);
      } else if(wallet.signAndSendTransaction){
        const res = await wallet.signAndSendTransaction(tx);
        const sig = res?.signature||res;
        await connection.confirmTransaction(sig,'confirmed');
        log(`âœ… Closed ${tokenAcctPubkey.toString()} â€” tx ${sig}`);
      } else{ throw new Error('Wallet cannot sign transaction'); }
    } catch(err){ log(`âŒ Failed to close ${tokenAcctPubkey.toString()}: ${err?.message||String(err)}`); }
  }

  log('ðŸŽ‰ Reclaim run complete.');
}

// ---------- BUTTONS ----------
document.getElementById('reclaimRentBtn').onclick = reclaimRent;

document.getElementById('connectWallet').onclick = async ()=>{
  clearLogs();
  const walletObj = getSelectedWallet();
  if(!walletObj){ log('âŒ No wallet selected.'); return; }
  try { await session.connect(walletObj); } 
  catch(err){ log('âŒ Connect failed: '+err.message); }
};

document.getElementById('disconnectWallet').onclick = async ()=>{
  await session.disconnectAll();
  log('ðŸ”„ Wallet disconnected.');
};

// ---------- INITIALIZE ----------
populateDropdown();
setInterval(populateDropdown, 3000); // re-detect wallets periodically
</script>
</body>
</html>
